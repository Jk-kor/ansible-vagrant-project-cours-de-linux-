---
- name: Configure HTTPS on Web Server
  hosts: web_servers
  become: yes

  tasks:
    # 1. (option) Forcer la suppression par nom de conteneur (éviter les conflits de montage/nom)
    - name: Force stop and remove nginx_proxy container (optional)
      shell: |
        docker stop nginx_proxy || true
        docker rm nginx_proxy || true
      ignore_errors: yes

  # 2. Créer le dossier de stockage des certificats
    - name: Create directory for certificates
      file:
        path: /home/vagrant/app/certs
        state: directory
        owner: vagrant
        group: vagrant

  # 3. index.html est géré côté source (app) : pas de création/écrasement forcé

  # 4. Générer le certificat et la clé SSL (auto-signés)
    - name: Generate Self-Signed SSL Certificate
      command: >
        openssl req -x509 -nodes -days 365 -newkey rsa:2048
        -keyout /home/vagrant/app/certs/server.key
        -out /home/vagrant/app/certs/server.crt
        -subj "/C=FR/ST=Nouvelle-Aquitaine/L=Bordeaux/O=FilRouge/CN=web"
      args:
        creates: /home/vagrant/app/certs/server.crt

    # 5. Nginx 설정 파일 생성 (HTTPS 설정 포함)
    - name: Create Nginx configuration file (default.conf)
      copy:
        dest: /home/vagrant/app/default.conf
        content: |
      server {
        listen 80;
        server_name localhost;
        # Rediriger HTTP vers HTTPS
        return 301 https://$host$request_uri;
      }

          server {
              listen 443 ssl;
              server_name localhost;

              ssl_certificate /etc/nginx/certs/server.crt;
              ssl_certificate_key /etc/nginx/certs/server.key;

              location / {
                  root /usr/share/nginx/html;
                  index index.html;
              }
          }

  # 6. docker-compose.yml est géré dans la source (app) : non modifié par ce playbook

  # 7. Les redémarrages sont centralisés dans final_deployment.yml
